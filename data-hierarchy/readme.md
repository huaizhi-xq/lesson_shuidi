# 数据结构的学习

## 数组
  js的数组就是API的调用
  1. concat    连接2个或更多数组，并返回结果
  2. every     () => {} 为如果该函数对每一项都返回 true，则返回true, 否则返回false
  3. filter    () => {} 返回true的项组成的数组
  4. forEach   () => {} 遍历没有返回值
  5. join      将所有的数组元素连接成一个字符串
  6. indexOf   返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1
  7. lastIndexOf  返回在数组中搜索到的与给定参数相等的元素的索引里最大的值
  8. map       () => {} 结果组成新的数组
  9. reverse   倒序
  10. slice    传入索引值，将数组里对应索引范围内的元素作为新数组返回
  11. some     () => {} 如果任一项返回 true，则结果为true, 并且迭代结束
  12. sort     按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数
  13. toString 将数组作为字符串返回
  14. valueOf  和 toString类似，将数组作为字符串返回
  15. reduce   (pre, cur) => { return pre + cur },pre   。。。

## 栈(stack)
  栈和队列就是比较常见的受限的线性结构
  后进先出LIFO 栈顶 栈底 入栈 出栈
  实现栈的俩种常见方式 1. 数组 2. 链表
  常见的： push pop peek(返回栈顶元素) isEmpty size toString

## 队列(queue)
  栈和队列就是比较常见的受限的线性结构
  先进先出FIFO
  实现队列的俩种常见方式 1. 数组 2. 链表
  前端front  后端rear
  常见的: enqueue dequeue front isEmpty size toString
  优先级队列
    插入一个元素的时候要考虑该数据的优先级

## 链表
  不同于数组，链表中的元素在内存中不必是连续的空间
  删除插入性能高  访问元素都需要从投开始性能低
  append(element) insert(position, element) 
  removeAt(position) remove(element)
  update(position,element)
  get(position) indexOf(element)
  isEmpty() size() toString()
  单向链表  很难回到前一个结点 
  双向链表  插入和删除困难一点 内存空间大一点
  forwardString() backwordString()

## 集合
  集合通常是一组无序的，不能重复的
  集合常见的实现方式是哈希表
  常见操作：add(value) remove(value) has(value) clear() size() values()
  集合间操作
    并集 交集 差集 子集 
  - 字典(映射 MAP。。。)
    一一对应的关系key->value 和js对象很像

## 哈希表
  哈希表的结构就是数组，通过对下标值的一种变换(哈希函数)，获取HashCode
  哈希表通常是基于数组进行实现的，相对于数组有很多优势
   1. 快速的插入-删除-查找
   2. 无论多少数据，插入和删除都是O(1)
   3. 哈希表的速度表树还要快
   4. 比树编码容易很多
  不足：
   1. 数据没有顺序
   2. key不允许重复
   3. 空间利用率不高
  哈希化： 将大数字转化成数组范围内下标的过程
  哈希函数： 通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数称为哈希函数
  哈希表： 最终将数据插入到的这个数组，对整个结构的封装，我们称之为哈希表
  冲突？
    1. 链地址法(拉链法)  
    2. 开放地址法 
      寻找空白的单元格来添加重复的数据
        线性探测 会产生聚集问题
        二次探测 会造成步长不一的聚集
        再哈希化 
  优秀的哈希函数？
    快速的计算    霍纳法则(尽快能减少乘法和除法)
    均匀分布      采用质数作为哈希表的长度
  扩容？ 质数
    loadFactor越大，哈希表的效率就越低
    通常loadFactor > 0.75 扩容  < 0.25 缩小容量

## 树(tree)
  n(n >= 0)个结点构成的有限集合   非线性结构 一对多
  儿子-兄弟表示法
  儿子-兄弟表示法旋转45度  可以模拟出二叉树
  二叉树的特性：
   1. 一个二叉树第i(i>=1)层的最大结点数： 2^(i-1)
   2. 深度为k(k>=1)的二叉树最大结点树: 2^k-1
   3. n0叶结点个数 n2是度为2的非叶结点个数那么: n0=n2+1
  完美二叉树： 满二叉树
  完全二叉树： 从左至右连续存在  只可以缺右侧
  二叉树存储常见的方式是数组和链表
  二叉搜索树？BST
    如果不为空，要满足的性质：
      1. 非空左子树的所有键值小于其根节点的键值
      2. 非空右子树的所有键值大于其根节点的键值
      3. 左，右子树本身也都是二叉搜索树
    特点：较小的值在左边，较大的值在右边   查找效率十分高 
    insert  递归  子树
    遍历 先序(根左右) 中序(左根右) 后序(左右根)
    最大值最小值
    搜索特定的值
    删除：叶节点  一个子节点 俩个子节点(前驱 后继)
    缺陷？
      如果插入的数据是有序的数据  那么深度会很深 即非平衡树
      AVL树  红黑树
    至少大部分是平衡的 那么时间复杂度也是接近O(logN)
  红黑树
    除了符合二叉搜索树的基本规则，还添加了一些特性：
     1. 节点是红色或黑色的
     2. 根节点是黑色的
     3. 每个叶子节点都是黑色的空节点(NIL节点)
     4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
     5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
    怎么相对平衡的？
     从根到叶子的最长可能路径，不会超过最短可能路径的两倍长？ -> 相对平衡
      性质5所有路径都有相同数目的黑色节点     -> 最短的可能路径都是黑色节点，最长的可能路径是有红色也有黑色
      性质4决定了路径不可能有俩个连续的红色节点   -> 最长的路径不超过最短路径的两倍 -> 基本平衡
    插入节点时，怎么保持平衡？
     插入的新节点通常是红色的 如果出现俩个连续的红色 那么：
      换色--左旋转--右旋转
     - 情况一:
        新节点N位于树的跟上，没有P父节点
        -> N黑
     - 情况二:
        新节点N的父节点P是黑色的
        不用操作
     - 情况三:
        P为红色，U也是红色，G黑
        -> G红P黑U黑    如果出现G的P是红色的那么可以递归解决
     - 情况四:
        P红U黑G黑 N为左儿子
        -> P黑G红 ->右旋转
     - 情况五:
        P红U黑G黑 N为右儿子
        -> 以P为根左旋转 (将P作为新插入的红色节点考虑) -> 情况四

## 图
      
    




  

  
  

    
